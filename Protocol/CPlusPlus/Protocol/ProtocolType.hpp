// Warning: This file is auto-generated by ParseProtocol.exe, you should not change it!
// Time: 2017-03-05 14:31:14
#ifndef _PROTOCOLTYPE_HPP_
#define _PROTOCOLTYPE_HPP_

#include "AquariusCore/Util/TypeReDef/TypeReDef.hpp"
#include "AquariusCore/Util/TinyUtil/CommonUtil.h"
#include "AquariusCore/Util/TinyUtil/StringUtil.h"
#include "AquariusCore/Logger/AquariusLogger.h"

const static std::string AQUARIUS_PROTOCOL_VERSION = "20170305T143114";

#pragma pack(push)
#pragma pack(1)
// Key value pair for huge param. [size: 482 ]
typedef struct KeyValuePair
{
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "KeyValuePair"; 
    }
    // Constructor of KeyValuePair
    KeyValuePair()
    {
        memset(key, 0, sizeof(key));
        memset(value, 0, sizeof(value));
    }
    // key
    char key[32];
    // value
    char value[450];
    // To net byte order for KeyValuePair
    inline void HostToNetStruct()
    {
    }
    // To host byte order for KeyValuePair
    inline void NetToHostStruct()
    {
    }
    // Write function of ValueToCStr for KeyValuePair
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field key
        s_strMsgValue.append("{k:");
        s_strMsgValue.append(CStringUtil::BuildSafeString(key));
        s_strMsgValue.append("}");
        // Append Field value
        s_strMsgValue.append("{v:");
        s_strMsgValue.append(CStringUtil::BuildSafeString(value));
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} KeyValuePair;
static_assert( sizeof( KeyValuePair ) == 482, "Check struct size failed for [KeyValuePair]");

// rand string value. [size: 32 ]
typedef struct RandString
{
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "RandString"; 
    }
    // Constructor of RandString
    RandString()
    {
        memset(data, 0, sizeof(data));
    }
    // rand string
    char data[32];
    // To net byte order for RandString
    inline void HostToNetStruct()
    {
    }
    // To host byte order for RandString
    inline void NetToHostStruct()
    {
    }
    // Write function of ValueToCStr for RandString
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field data
        s_strMsgValue.append("{d:");
        s_strMsgValue.append(CStringUtil::BuildSafeString(data));
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} RandString;
static_assert( sizeof( RandString ) == 32, "Check struct size failed for [RandString]");

// response code enum value
enum class EResponseCode : short 
{
    // invalid
    Invalid = -1,
    // success
    G_Success = 0,
    // system error
    G_SystemError = 1,
    // parameter is invalid
    G_InvalidParam = 3,
};

// ToCStr function for type EResponseCode
static inline const char* EResponseCodeToCStr( EResponseCode nCode )
{
    if (EResponseCode::Invalid == nCode) { return "Invalid"; }
    if (EResponseCode::G_Success == nCode) { return "G_Success"; }
    if (EResponseCode::G_SystemError == nCode) { return "G_SystemError"; }
    if (EResponseCode::G_InvalidParam == nCode) { return "G_InvalidParam"; }
    CAquariusLogger::Logger(LL_ERROR_FUN, "Invalid enum value: %d", nCode);
    static char buff[64] = { 0 };
    a_sprintf(buff, "%hd", nCode);
    return buff;
}

// echo msg, which can't bigger than 512byte. [size: 270 ]
typedef struct EchoMsg
{
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "EchoMsg"; 
    }
    // Constructor of EchoMsg
    EchoMsg()
        :int_param(0),
        enum_value(EResponseCode::Invalid)
    {
        memset(protocol_version, 0, sizeof(protocol_version));
        memset(int_array, 0, sizeof(int_array));
        memset(char_array, 0, sizeof(char_array));
        memset(rand_string_array, 0, sizeof(rand_string_array));
    }
    // protocol version
    char protocol_version[32];
    // single field, available type: AUINT32, AINT32, AUINT16, AINT16, AUINT8, AINT8
    AUINT32 int_param;
    // array param, you can change element_count to set array size
    AUINT32 int_array[10];
    // char array, hold string value
    char char_array[32];
    // rand string field, the type can be pre-define struct
    RandString rand_string_field;
    // rand struct array
    RandString rand_string_array[4];
    // enum value
    EResponseCode enum_value;
    // To net byte order for EchoMsg
    inline void HostToNetStruct()
    {
        int_param = CCommonUtil::HostToNet32(int_param);
        for( size_t nIndex = 0; nIndex < A_ARRAY_SIZE(int_array); ++nIndex)
        {
            int_array[nIndex] = CCommonUtil::HostToNet32(int_array[nIndex]);
        }
        rand_string_field.HostToNetStruct();
        for( size_t nIndex = 0; nIndex < A_ARRAY_SIZE(rand_string_array); ++nIndex)
        {
            rand_string_array[nIndex].HostToNetStruct();
        }
        enum_value = (EResponseCode)CCommonUtil::HostToNet16((short)enum_value);
    }
    // To host byte order for EchoMsg
    inline void NetToHostStruct()
    {
        int_param = CCommonUtil::NetToHost32(int_param);
        for( size_t nIndex = 0; nIndex < A_ARRAY_SIZE(int_array); ++nIndex)
        {
            int_array[nIndex] = CCommonUtil::NetToHost32(int_array[nIndex]);
        }
        rand_string_field.NetToHostStruct();
        for( size_t nIndex = 0; nIndex < A_ARRAY_SIZE(rand_string_array); ++nIndex)
        {
            rand_string_array[nIndex].NetToHostStruct();
        }
        enum_value = (EResponseCode)CCommonUtil::NetToHost16((short)enum_value);
    }
    // Write function of ValueToCStr for EchoMsg
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field protocol_version
        s_strMsgValue.append("{pv:");
        s_strMsgValue.append(CStringUtil::BuildSafeString(protocol_version));
        s_strMsgValue.append("}");
        // Append Field int_param
        s_strMsgValue.append("{ip:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_param));
        s_strMsgValue.append("}");
        // Append Field int_array
        s_strMsgValue.append("{ia:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[0])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[1])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[2])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[3])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[4])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[5])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[6])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[7])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[8])).append(";");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(int_array[9])).append(";");
        s_strMsgValue.append("}");
        // Append Field char_array
        s_strMsgValue.append("{ca:");
        s_strMsgValue.append(CStringUtil::BuildSafeString(char_array));
        s_strMsgValue.append("}");
        // Append Field rand_string_field
        s_strMsgValue.append("{rsf:");
        s_strMsgValue.append(rand_string_field.ValueToCStr());
        s_strMsgValue.append("}");
        // Append Field rand_string_array
        s_strMsgValue.append("{rsa:");
        int nIndex = -1; 
        for each ( const RandString& stValue in rand_string_array)
        {
            s_strMsgValue.append("<E").append(CStringUtil::Int32ToDecString(++nIndex)).append(":");
            s_strMsgValue.append(stValue.ValueToCStr());
            s_strMsgValue.append(">");
        }
        s_strMsgValue.append("}");
        // Append Field enum_value
        s_strMsgValue.append("{ev:");
        s_strMsgValue.append(EResponseCodeToCStr(enum_value));
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} EchoMsg;
static_assert( sizeof( EchoMsg ) == 270, "Check struct size failed for [EchoMsg]");

// chat msg. [size: 264 ]
typedef struct ChatMsg
{
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "ChatMsg"; 
    }
    // Constructor of ChatMsg
    ChatMsg()
        :speaker_id(0),
        time(0)
    {
        memset(content, 0, sizeof(content));
    }
    // chat content
    char content[256];
    // speaker id
    AUINT32 speaker_id;
    // time
    AUINT32 time;
    // To net byte order for ChatMsg
    inline void HostToNetStruct()
    {
        speaker_id = CCommonUtil::HostToNet32(speaker_id);
        time = CCommonUtil::HostToNet32(time);
    }
    // To host byte order for ChatMsg
    inline void NetToHostStruct()
    {
        speaker_id = CCommonUtil::NetToHost32(speaker_id);
        time = CCommonUtil::NetToHost32(time);
    }
    // Write function of ValueToCStr for ChatMsg
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field content
        s_strMsgValue.append("{c:");
        s_strMsgValue.append(CStringUtil::BuildSafeString(content));
        s_strMsgValue.append("}");
        // Append Field speaker_id
        s_strMsgValue.append("{si:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(speaker_id));
        s_strMsgValue.append("}");
        // Append Field time
        s_strMsgValue.append("{t:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(time));
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} ChatMsg;
static_assert( sizeof( ChatMsg ) == 264, "Check struct size failed for [ChatMsg]");

#pragma pack(pop)
#endif // _PROTOCOLTYPE_HPP_
