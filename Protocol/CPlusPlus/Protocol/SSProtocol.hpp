// Warning: This file is auto-generated by ParseProtocol.exe, you should not change it!
// Time: 2017-03-05 14:31:14
#ifndef _SSPROTOCOL_HPP_
#define _SSPROTOCOL_HPP_

#include "AquariusCore/Util/TypeReDef/TypeReDef.hpp"
#include "AquariusCore/Util/TinyUtil/CommonUtil.h"
#include "AquariusCore/Logger/AquariusLogger.h"
#include "Protocol/ProtocolType.hpp"

#pragma pack(push)
#pragma pack(1)
// heart beat msg between server. [size: 8 ]
static const unsigned short SS_HeartBeat_Msg_Id = 0x43ae;
typedef struct SS_HeartBeat_Msg
{
    // Get id of this msg
    static inline const unsigned short GetMsgId()
    {
        return SS_HeartBeat_Msg_Id; 
    }
    // Get inline monitor flag this msg
    static inline bool GetMonitorFlag()
    {
        return false; 
    }
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "SS_HeartBeat_Msg"; 
    }
    // Constructor of SS_HeartBeat_Msg
    SS_HeartBeat_Msg()
        :msg_len(sizeof(SS_HeartBeat_Msg)),
        msg_id(SS_HeartBeat_Msg_Id),
        server_type(0),
        heartbeat_index(0)
    {
    }
    // msg len, you should not change the value
    AUINT16 msg_len;
    // msg id, you should not change the value
    AUINT16 msg_id;
    // self server type
    AUINT16 server_type;
    // heart beat index
    AUINT16 heartbeat_index;
    // To net byte order for SS_HeartBeat_Msg
    inline void HostToNetStruct()
    {
        msg_len = CCommonUtil::HostToNet16(msg_len);
        msg_id = CCommonUtil::HostToNet16(msg_id);
        server_type = CCommonUtil::HostToNet16(server_type);
        heartbeat_index = CCommonUtil::HostToNet16(heartbeat_index);
    }
    // To host byte order for SS_HeartBeat_Msg
    inline void NetToHostStruct()
    {
        msg_len = CCommonUtil::NetToHost16(msg_len);
        msg_id = CCommonUtil::NetToHost16(msg_id);
        server_type = CCommonUtil::NetToHost16(server_type);
        heartbeat_index = CCommonUtil::NetToHost16(heartbeat_index);
    }
    // Write function of ValueToCStr for SS_HeartBeat_Msg
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field msg_len
        s_strMsgValue.append("{ml:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_len));
        s_strMsgValue.append("}");
        // Append Field msg_id
        s_strMsgValue.append("{mi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_id));
        s_strMsgValue.append("}");
        // Append Field server_type
        s_strMsgValue.append("{st:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(server_type));
        s_strMsgValue.append("}");
        // Append Field heartbeat_index
        s_strMsgValue.append("{hi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(heartbeat_index));
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} SS_HeartBeat_Msg;
static_assert( sizeof( SS_HeartBeat_Msg ) == 8, "Check struct size failed for [SS_HeartBeat_Msg]");

// chat cmd. [size: 268 ]
static const unsigned short GF_Chat_Cmd_Id = 0x28a2;
typedef struct GF_Chat_Cmd
{
    // Get id of this msg
    static inline const unsigned short GetMsgId()
    {
        return GF_Chat_Cmd_Id; 
    }
    // Get inline monitor flag this msg
    static inline bool GetMonitorFlag()
    {
        return false; 
    }
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "GF_Chat_Cmd"; 
    }
    // Constructor of GF_Chat_Cmd
    GF_Chat_Cmd()
        :msg_len(sizeof(GF_Chat_Cmd)),
        msg_id(GF_Chat_Cmd_Id)
    {
    }
    // msg len, you should not change the value
    AUINT16 msg_len;
    // msg id, you should not change the value
    AUINT16 msg_id;
    // chat content
    ChatMsg data;
    // To net byte order for GF_Chat_Cmd
    inline void HostToNetStruct()
    {
        msg_len = CCommonUtil::HostToNet16(msg_len);
        msg_id = CCommonUtil::HostToNet16(msg_id);
        data.HostToNetStruct();
    }
    // To host byte order for GF_Chat_Cmd
    inline void NetToHostStruct()
    {
        msg_len = CCommonUtil::NetToHost16(msg_len);
        msg_id = CCommonUtil::NetToHost16(msg_id);
        data.NetToHostStruct();
    }
    // Write function of ValueToCStr for GF_Chat_Cmd
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field msg_len
        s_strMsgValue.append("{ml:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_len));
        s_strMsgValue.append("}");
        // Append Field msg_id
        s_strMsgValue.append("{mi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_id));
        s_strMsgValue.append("}");
        // Append Field data
        s_strMsgValue.append("{d:");
        s_strMsgValue.append(data.ValueToCStr());
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} GF_Chat_Cmd;
static_assert( sizeof( GF_Chat_Cmd ) == 268, "Check struct size failed for [GF_Chat_Cmd]");

// common struct request. [size: 278 ]
static const unsigned short GF_Echo_Request_Id = 0x38b4;
typedef struct GF_Echo_Request
{
    // Get id of this msg
    static inline const unsigned short GetMsgId()
    {
        return GF_Echo_Request_Id; 
    }
    // Get inline monitor flag this msg
    static inline bool GetMonitorFlag()
    {
        return false; 
    }
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "GF_Echo_Request"; 
    }
    // Constructor of GF_Echo_Request
    GF_Echo_Request()
        :msg_len(sizeof(GF_Echo_Request)),
        msg_id(GF_Echo_Request_Id),
        client_session_id(0)
    {
    }
    // msg len, you should not change the value
    AUINT16 msg_len;
    // msg id, you should not change the value
    AUINT16 msg_id;
    // client session id
    AUINT32 client_session_id;
    // msg field
    EchoMsg data;
    // To net byte order for GF_Echo_Request
    inline void HostToNetStruct()
    {
        msg_len = CCommonUtil::HostToNet16(msg_len);
        msg_id = CCommonUtil::HostToNet16(msg_id);
        client_session_id = CCommonUtil::HostToNet32(client_session_id);
        data.HostToNetStruct();
    }
    // To host byte order for GF_Echo_Request
    inline void NetToHostStruct()
    {
        msg_len = CCommonUtil::NetToHost16(msg_len);
        msg_id = CCommonUtil::NetToHost16(msg_id);
        client_session_id = CCommonUtil::NetToHost32(client_session_id);
        data.NetToHostStruct();
    }
    // Write function of ValueToCStr for GF_Echo_Request
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field msg_len
        s_strMsgValue.append("{ml:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_len));
        s_strMsgValue.append("}");
        // Append Field msg_id
        s_strMsgValue.append("{mi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_id));
        s_strMsgValue.append("}");
        // Append Field client_session_id
        s_strMsgValue.append("{csi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(client_session_id));
        s_strMsgValue.append("}");
        // Append Field data
        s_strMsgValue.append("{d:");
        s_strMsgValue.append(data.ValueToCStr());
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} GF_Echo_Request;
static_assert( sizeof( GF_Echo_Request ) == 278, "Check struct size failed for [GF_Echo_Request]");

// common struct response. [size: 280 ]
static const unsigned short FG_Echo_Response_Id = 0x2c09;
typedef struct FG_Echo_Response
{
    // Get id of this msg
    static inline const unsigned short GetMsgId()
    {
        return FG_Echo_Response_Id; 
    }
    // Get inline monitor flag this msg
    static inline bool GetMonitorFlag()
    {
        return false; 
    }
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "FG_Echo_Response"; 
    }
    // Constructor of FG_Echo_Response
    FG_Echo_Response()
        :msg_len(sizeof(FG_Echo_Response)),
        msg_id(FG_Echo_Response_Id),
        client_session_id(0),
        response_code(EResponseCode::Invalid)
    {
    }
    // msg len, you should not change the value
    AUINT16 msg_len;
    // msg id, you should not change the value
    AUINT16 msg_id;
    // client session id
    AUINT32 client_session_id;
    // msg field
    EchoMsg data;
    // ResponseCode
    EResponseCode response_code;
    // To net byte order for FG_Echo_Response
    inline void HostToNetStruct()
    {
        msg_len = CCommonUtil::HostToNet16(msg_len);
        msg_id = CCommonUtil::HostToNet16(msg_id);
        client_session_id = CCommonUtil::HostToNet32(client_session_id);
        data.HostToNetStruct();
        response_code = (EResponseCode)CCommonUtil::HostToNet16((short)response_code);
    }
    // To host byte order for FG_Echo_Response
    inline void NetToHostStruct()
    {
        msg_len = CCommonUtil::NetToHost16(msg_len);
        msg_id = CCommonUtil::NetToHost16(msg_id);
        client_session_id = CCommonUtil::NetToHost32(client_session_id);
        data.NetToHostStruct();
        response_code = (EResponseCode)CCommonUtil::NetToHost16((short)response_code);
    }
    // Write function of ValueToCStr for FG_Echo_Response
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field msg_len
        s_strMsgValue.append("{ml:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_len));
        s_strMsgValue.append("}");
        // Append Field msg_id
        s_strMsgValue.append("{mi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_id));
        s_strMsgValue.append("}");
        // Append Field client_session_id
        s_strMsgValue.append("{csi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(client_session_id));
        s_strMsgValue.append("}");
        // Append Field data
        s_strMsgValue.append("{d:");
        s_strMsgValue.append(data.ValueToCStr());
        s_strMsgValue.append("}");
        // Append Field response_code
        s_strMsgValue.append("{rc:");
        s_strMsgValue.append(EResponseCodeToCStr(response_code));
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} FG_Echo_Response;
static_assert( sizeof( FG_Echo_Response ) == 280, "Check struct size failed for [FG_Echo_Response]");

// common struct request. [size: 282 ]
static const unsigned short GH_Echo_Request_Id = 0x23cf;
typedef struct GH_Echo_Request
{
    // Get id of this msg
    static inline const unsigned short GetMsgId()
    {
        return GH_Echo_Request_Id; 
    }
    // Get inline monitor flag this msg
    static inline bool GetMonitorFlag()
    {
        return false; 
    }
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "GH_Echo_Request"; 
    }
    // Constructor of GH_Echo_Request
    GH_Echo_Request()
        :msg_len(sizeof(GH_Echo_Request)),
        msg_id(GH_Echo_Request_Id),
        client_session_id(0),
        server_group_id(0)
    {
    }
    // msg len, you should not change the value
    AUINT16 msg_len;
    // msg id, you should not change the value
    AUINT16 msg_id;
    // client session id
    AUINT32 client_session_id;
    // server group id
    AUINT32 server_group_id;
    // msg field
    EchoMsg data;
    // To net byte order for GH_Echo_Request
    inline void HostToNetStruct()
    {
        msg_len = CCommonUtil::HostToNet16(msg_len);
        msg_id = CCommonUtil::HostToNet16(msg_id);
        client_session_id = CCommonUtil::HostToNet32(client_session_id);
        server_group_id = CCommonUtil::HostToNet32(server_group_id);
        data.HostToNetStruct();
    }
    // To host byte order for GH_Echo_Request
    inline void NetToHostStruct()
    {
        msg_len = CCommonUtil::NetToHost16(msg_len);
        msg_id = CCommonUtil::NetToHost16(msg_id);
        client_session_id = CCommonUtil::NetToHost32(client_session_id);
        server_group_id = CCommonUtil::NetToHost32(server_group_id);
        data.NetToHostStruct();
    }
    // Write function of ValueToCStr for GH_Echo_Request
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field msg_len
        s_strMsgValue.append("{ml:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_len));
        s_strMsgValue.append("}");
        // Append Field msg_id
        s_strMsgValue.append("{mi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_id));
        s_strMsgValue.append("}");
        // Append Field client_session_id
        s_strMsgValue.append("{csi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(client_session_id));
        s_strMsgValue.append("}");
        // Append Field server_group_id
        s_strMsgValue.append("{sgi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(server_group_id));
        s_strMsgValue.append("}");
        // Append Field data
        s_strMsgValue.append("{d:");
        s_strMsgValue.append(data.ValueToCStr());
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} GH_Echo_Request;
static_assert( sizeof( GH_Echo_Request ) == 282, "Check struct size failed for [GH_Echo_Request]");

// common struct response. [size: 280 ]
static const unsigned short HG_Echo_Response_Id = 0x3560;
typedef struct HG_Echo_Response
{
    // Get id of this msg
    static inline const unsigned short GetMsgId()
    {
        return HG_Echo_Response_Id; 
    }
    // Get inline monitor flag this msg
    static inline bool GetMonitorFlag()
    {
        return false; 
    }
    // Get msg name
    static inline const char* GetMsgName()
    {
        return "HG_Echo_Response"; 
    }
    // Constructor of HG_Echo_Response
    HG_Echo_Response()
        :msg_len(sizeof(HG_Echo_Response)),
        msg_id(HG_Echo_Response_Id),
        client_session_id(0),
        response_code(EResponseCode::Invalid)
    {
    }
    // msg len, you should not change the value
    AUINT16 msg_len;
    // msg id, you should not change the value
    AUINT16 msg_id;
    // client session id
    AUINT32 client_session_id;
    // msg field
    EchoMsg data;
    // ResponseCode
    EResponseCode response_code;
    // To net byte order for HG_Echo_Response
    inline void HostToNetStruct()
    {
        msg_len = CCommonUtil::HostToNet16(msg_len);
        msg_id = CCommonUtil::HostToNet16(msg_id);
        client_session_id = CCommonUtil::HostToNet32(client_session_id);
        data.HostToNetStruct();
        response_code = (EResponseCode)CCommonUtil::HostToNet16((short)response_code);
    }
    // To host byte order for HG_Echo_Response
    inline void NetToHostStruct()
    {
        msg_len = CCommonUtil::NetToHost16(msg_len);
        msg_id = CCommonUtil::NetToHost16(msg_id);
        client_session_id = CCommonUtil::NetToHost32(client_session_id);
        data.NetToHostStruct();
        response_code = (EResponseCode)CCommonUtil::NetToHost16((short)response_code);
    }
    // Write function of ValueToCStr for HG_Echo_Response
    inline const char* ValueToCStr() const
    {
        static std::string s_strMsgValue;
        s_strMsgValue.clear();
        s_strMsgValue.reserve(2048);
        // Append Field msg_len
        s_strMsgValue.append("{ml:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_len));
        s_strMsgValue.append("}");
        // Append Field msg_id
        s_strMsgValue.append("{mi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(msg_id));
        s_strMsgValue.append("}");
        // Append Field client_session_id
        s_strMsgValue.append("{csi:");
        s_strMsgValue.append(CStringUtil::UInt32ToDecString(client_session_id));
        s_strMsgValue.append("}");
        // Append Field data
        s_strMsgValue.append("{d:");
        s_strMsgValue.append(data.ValueToCStr());
        s_strMsgValue.append("}");
        // Append Field response_code
        s_strMsgValue.append("{rc:");
        s_strMsgValue.append(EResponseCodeToCStr(response_code));
        s_strMsgValue.append("}");
        return s_strMsgValue.c_str();
    }
} HG_Echo_Response;
static_assert( sizeof( HG_Echo_Response ) == 280, "Check struct size failed for [HG_Echo_Response]");

#pragma pack(pop)
#endif // _SSPROTOCOL_HPP_
